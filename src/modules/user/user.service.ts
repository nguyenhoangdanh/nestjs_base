// src/modules/user/user.service.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { IUserService, IUserRepository } from './user.port';
import { User } from './user.model';
import {
  CreateUserDto,
  UpdateUserDto,
  UserFilterDto,
  PaginationDto,
} from './user.dto';
import { Paginated, Requester, AppError, UserRole } from '../../share';
import { randomBytes } from 'crypto';
import * as bcrypt from 'bcrypt';
import * as speakeasy from 'speakeasy';
import * as QRCode from 'qrcode';
import { USER_REPOSITORY } from './user.di-token';
import { ROLE_REPOSITORY } from '../role/role.di-token';
import { IRoleRepository } from '../role/role.port';

@Injectable()
export class UserService implements IUserService {
  private readonly logger = new Logger(UserService.name);

  constructor(
    @Inject(USER_REPOSITORY) private readonly userRepo: IUserRepository,
    @Inject(ROLE_REPOSITORY) private readonly roleRepo: IRoleRepository,
  ) {}

  async createUser(dto: CreateUserDto): Promise<string> {
    try {
      // Check if user already exists
      const existingUser = await this.userRepo.findByEmail(dto.email);
      if (existingUser) {
        throw AppError.from(
          new Error('User with this email already exists'),
          400,
        );
      }

      // Hash password if provided
      let hashedPassword: string | null = null;
      if (dto.password) {
        hashedPassword = await bcrypt.hash(dto.password, 10);
      }

      // Create verification code
      const verifyCode = randomBytes(32).toString('hex');
      const verifyExpires = new Date();
      verifyExpires.setHours(verifyExpires.getHours() + 24); // 24 hours validity

      // Create new user
      const user: User = {
        ...dto,
        id: '', // Will be generated by DB
        password: hashedPassword,
        isActive: true,
        isVerified: false,
        verifyCode,
        verifyExpires,
        isTwoFactorEnabled: false,
        twoFactorSecret: null,
        twoFactorBackupCodes: [],
        resetToken: null,
        resetTokenExpires: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const userId = await this.userRepo.insert(user);

      this.logger.log(`User created with ID: ${userId}`);
      return userId;
    } catch (error) {
      this.logger.error(`Error creating user: ${error.message}`, error.stack);
      if (error instanceof AppError) {
        throw error;
      }
      throw AppError.from(
        new Error(`Failed to create user: ${error.message}`),
        500,
      );
    }
  }

  async getUser(id: string): Promise<User> {
    const user = await this.userRepo.get(id);
    if (!user) {
      throw AppError.from(new Error('User not found'), 404);
    }
    return user;
  }

  async updateUser(
    requester: Requester,
    id: string,
    dto: UpdateUserDto,
  ): Promise<void> {
    // Check if user exists
    const user = await this.getUser(id);

    // Check permissions - only allow users to update themselves unless admin
    if (
      requester.sub !== id &&
      requester.role !== UserRole.ADMIN &&
      requester.role !== UserRole.SUPER_ADMIN
    ) {
      throw AppError.from(
        new Error('You do not have permission to update this user'),
        403,
      );
    }

    // Update user
    await this.userRepo.update(id, {
      ...dto,
      updatedAt: new Date(),
    });

    this.logger.log(`User ${id} updated by ${requester.sub}`);
  }

  async deleteUser(
    requester: Requester,
    id: string,
    hardDelete: boolean = false,
  ): Promise<void> {
    // Check if user exists
    const user = await this.getUser(id);

    // Check permissions - only allow admins to delete users
    if (
      requester.role !== UserRole.ADMIN &&
      requester.role !== UserRole.SUPER_ADMIN
    ) {
      throw AppError.from(
        new Error('You do not have permission to delete users'),
        403,
      );
    }

    // Delete user
    await this.userRepo.delete(id, hardDelete);

    this.logger.log(
      `User ${id} ${hardDelete ? 'hard' : 'soft'} deleted by ${requester.sub}`,
    );
  }

  async listUsers(
    requester: Requester,
    filter: UserFilterDto,
    pagination: PaginationDto,
  ): Promise<Paginated<User>> {
    // Check permissions - only admins can list all users
    if (
      requester.role !== UserRole.ADMIN &&
      requester.role !== UserRole.SUPER_ADMIN
    ) {
      throw AppError.from(
        new Error('You do not have permission to list users'),
        403,
      );
    }

    return this.userRepo.list(filter, pagination);
  }

  async getUserProfile(userId: string): Promise<User> {
    const user = await this.getUser(userId);
    // Remove sensitive fields
    const {
      password,
      resetToken,
      resetTokenExpires,
      twoFactorSecret,
      ...profile
    } = user;
    return profile as User;
  }

  async generateVerifyCode(userId: string): Promise<string> {
    const verifyCode = randomBytes(32).toString('hex');
    const verifyExpires = new Date();
    verifyExpires.setHours(verifyExpires.getHours() + 24); // 24 hours validity

    await this.userRepo.setVerifyCode(userId, verifyCode, verifyExpires);
    return verifyCode;
  }

  async verifyEmail(code: string): Promise<boolean> {
    const user = await this.userRepo.findByVerifyCode(code);
    if (!user) {
      return false;
    }

    await this.userRepo.verify(user.id);
    return true;
  }

  async updatePassword(userId: string, newPassword: string): Promise<void> {
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    await this.userRepo.updatePassword(userId, hashedPassword);
  }

  async setup2FA(
    userId: string,
  ): Promise<{ secret: string; qrCodeUrl: string }> {
    // Generate a secret
    const secret = speakeasy.generateSecret({
      name: `YourApp:${userId}`,
    });

    // Store the secret
    await this.userRepo.set2FASecret(userId, secret.base32);

    // Generate QR code
    const otpauth = secret.otpauth_url;
    const qrCodeUrl = await QRCode.toDataURL(otpauth as string);

    return {
      secret: secret.base32,
      qrCodeUrl,
    };
  }

  async verify2FA(userId: string, token: string): Promise<boolean> {
    const user = await this.getUser(userId);

    if (!user.twoFactorSecret) {
      throw AppError.from(new Error('2FA is not set up for this user'), 400);
    }

    // Check if token is a backup code
    if (user.twoFactorBackupCodes.includes(token)) {
      // Remove the used backup code
      const updatedBackupCodes = user.twoFactorBackupCodes.filter(
        (code) => code !== token,
      );
      await this.userRepo.set2FABackupCodes(userId, updatedBackupCodes);
      return true;
    }

    // Verify TOTP token
    const verified = speakeasy.totp.verify({
      secret: user.twoFactorSecret,
      encoding: 'base32',
      token,
    });

    return verified;
  }

  async enable2FA(userId: string, enabled: boolean): Promise<void> {
    await this.userRepo.enable2FA(userId, enabled);
  }

  async generate2FABackupCodes(userId: string): Promise<string[]> {
    // Generate 8 backup codes
    const backupCodes = Array.from({ length: 8 }, () =>
      randomBytes(4).toString('hex'),
    );

    await this.userRepo.set2FABackupCodes(userId, backupCodes);
    return backupCodes;
  }

  async getUserRoles(
    userId: string,
  ): Promise<{ roleId: string; role: UserRole }[]> {
    return this.userRepo.getUserRoles(userId);
  }

  async canAccessResource(
    userId: string,
    resourceType: string,
    resourceId: string,
  ): Promise<boolean> {
    // Get user roles
    const userRoles = await this.userRepo.getUserRoles(userId);

    // Admin and SuperAdmin have access to everything
    if (
      userRoles.some(
        (r) => r.role === UserRole.ADMIN || r.role === UserRole.SUPER_ADMIN,
      )
    ) {
      return true;
    }

    // For other roles, implement resource-specific access control
    // This would be implemented differently based on your resource types
    // For example, checking if a user has access to a specific device or notification

    // Default to denying access
    return false;
  }
}
